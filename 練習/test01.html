<!DOCTYPE html>
<html lang="tw">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="js/jquery-3.6.0.min.js"></script>

    <script>
        //https://www.youtube.com/watch?v=_vFuDQ_6Xt8
        let test = [
            {
                name : 'a',  
                thing : '草莓',
                money : 70
            },
            {
                name: '0000',
                thing : '銅鑼燒',
                money : 50
            },
            {
                name : '778',
                thing : '西瓜',
                money : 100
            },
            {
                name: '多拉A夢',
                thing : '銅鑼燒',
                money : 300
            },

        ]
    
        // 查看obj跟key內容
        // test.forEach(function(obj,key){                   //兩個參數命名為obj跟key 可改
        //     console.log('item : ' ,obj ,'index :' ,key);  //obj對應上面的參數 是物件內容 key是索引值
        // })






        //將每個物件都新增一個新價格 命名為newMoney
        //方法一 用push forEach迴圈重複多次將每個物件都推一個新內容進去
        // const newObj = [];                    //宣告陣列型態
        // test.forEach(function(obj,key){       //test物件執行forEach迴圈 
        //     newObj.push({                     //push語法 .push({內容})
        //         ...obj,                       //展開obj物件
        //         newMoney : obj.money*0.8      //新建物件newMoney 對應: obj.money * 0.8 取obj裡的money數值*0.8
        //     })
        // })
        // console.log(newObj)

        // const newObj = [];              
        // test.forEach(function(obj,key){    //forEach根據陣列內有幾個物件而決定做幾次for迴圈
        //     newObj [key]={                 //根據索引值將每個物件內容都執行    26:35影片位置 ES6寫法
        //         ...obj,                    //展開 在這裡為展開obj內容
        //         newMoney: obj.money*0.8    //建立新物件newMoney 對應 obj(原先物件).money(裡面的money) * 0.8
        //     } 
        // })
        // console.log(newObj)

        //方法二 .map 比上面更好
        // const change = test.map(function(obj,key){
        //     return{                                  //回傳
        //         ...obj,                              //展開
        //         newMoney : obj.money * 0.8           //建立新物件
        //     }
        // })
        // console.log(change)

        //方法三 .map的箭頭函式
        // const change = test.map((obj,key,arr) => ({
        //                                              //箭頭函式已經自帶return 因此不用寫
        //         ...obj,                              //展開
        //         newMoney : obj.money * 0.8           //建立新物件
        //     }));
            
        // console.log(change)





        // 將物件內的name thing money按照順序放到其他多個陣列 再將其他多個陣列放到一個陣列內
        // const qq = [];
        // const qq1 = [];
        // const qq2 = [];
        // const qq3 = [];
        
        // test.forEach(item => {
        //     qq1.push(item.name)
        //     qq2.push(item.thing)
        //     qq3.push(item.money)
        // })
        // // qq.push('姓名:',qq1,
        // //         '物品:',qq2,
        // //         '金額:',qq3)

        
        // qq.push( `<a>姓名:${qq1}, <br> 物品:${qq2}, <br> 金額:${qq3}</a>` )

        // $(function(){
        //     $('#menu').html(qq);
        // })
        // // $(function(){
        // //     $('#menu').html(`<a>姓名:${qq1}, <br> 物品:${qq2}, <br> 金額:${qq3}</a>`);
        // // })
        // console.log(qq)


        const sql ='Oracle , MySQL , Microsoft SQL Server , PostgreSQL , MongoDB , Redis , IBM Db2, Elasticsearch, SQLite , Microsoft Access, Cassandra , MariaDB , Splunk, Hive, Microsoft Azure SQL Database, Amazon DynamoDB , Teradata, Neo4j , SAP HANA , Solr, FileMaker, SAP Adaptive Server, Snowflake , HBase  , Google BigQuery , Microsoft Azure Cosmos DB , PostGIS, InfluxDB , Couchbase , Memcached, Firebird, Informix, Amazon Redshift , Spark SQL, Vertica , Netezza, Impala, Firebase Realtime Database, Microsoft Azure Synapse Analytics, CouchDB, dBASE, Greenplum, Presto, Amazon Aurora, ClickHouse, etcd, H2, MarkLogic , Hazelcast , Realm , Kdb+ , Datastax Enterprise , Google Cloud Firestore, Sphinx, Oracle Essbase, Algolia, Ehcache, CockroachDB , Interbase, Prometheus, Microsoft Azure Search, Jackrabbit, SAP SQL Anywhere, OpenEdge, Ingres, Riak KV, SingleStore , Microsoft Azure Table Storage, Aerospike , SAP IQ, Ignite, Graphite, Microsoft Azure Data Explorer , HyperSQL, MaxDB, Derby, Google Cloud Datastore, Adabas, EXASOL, ArangoDB , Virtuoso , SAP Advantage Database Server, OrientDB, Accumulo, Oracle NoSQL, UniData,UniVerse, RocksDB, ScyllaDB , TimescaleDB , IBM Cloudant, Google Cloud Bigtable, RavenDB , Google Cloud Spanner, RethinkDB, Apache Druid, InterSystems Caché, Apache Jena - TDB, LevelDB, Infinispan, Oracle Berkeley DB, PouchDB, Apache Phoenix , IMS, Oracle Coherence, 4D, GraphDB , Apache Drill, RRDtool, JanusGraph, Percona Server for MySQL, Amazon Neptune, TiDB , Amazon CloudSearch, Amazon SimpleDB, LMDB, Tibero, EDB Postgres , CloudKit, MonetDB , TigerGraph , TimesTen, Trino, OpenTSDB, Datomic, SpatiaLite, Dgraph , InterSystems IRIS , VoltDB, Db4o, jBASE, Stardog , Geode, mSQL, IBM Db2 warehouse, GridGain, Fauna , BaseX, Tarantool , ObjectStore, Citus, 1010data, GT.M, Actian NoSQL Database, GridDB , Empress, SQLBase, Datameer, Mnesia, FoundationDB, AllegroGraph , Cubrid, Oracle Rdb, Amazon DocumentDB, Model 204, HFSQL, Giraph, Infobright, OmniSci , Apache Kylin , YugabyteDB, D3, DataEase, SQL.JS, LiteDB, NonStop SQL, Altibase, NuoDB, IDMS, Nebula Graph , DolphinDB, Sedna, Matisse, GBase, HAWQ, ZODB, Objectivity/DB, Datacom/DB, Kognitio, NCache , HPE Ezmeral Data Fabric, FrontBase, Actian Vector, GemStone/S, ObjectBox, Alibaba Cloud MaxCompute, solidDB, EventStoreDB , DBISAM, Blazegraph, BigchainDB, eXist-db, Alibaba Cloud AnalyticDB for MySQL , Xapian, CrateDB , Yellowbrick, KairosDB, HarperDB , TypeDB , WebSphere eXtreme Scale, Graph Engine, OpenBase, ScaleArc, eXtremeDB , SciDB, R:BASE, Splice Machine, Amazon Timestream, Alibaba Cloud ApsaraDB for PolarDB , SQream DB, Kinetica, ObjectDB, GeoMesa, AlaSQL, Alibaba Cloud AnalyticDB for PostgreSQL, QuestDB , RDF4J, Postgres-XL, NexusDB, VistaDB, Tokyo Tyrant, Percona Server for MongoDB, Elassandra, Perst, BoltDB, GigaSpaces InsightEdge , OpenInsight, LokiJS, Jade, Rockset, MapDB, Trafodion, Raima Database Manager, VictoriaMetrics, Scalaris, Rasdaman, Redland, Alibaba Cloud Log Service , Yandex Database, InfiniteGraph, Hibari, Amazon Keyspaces, Lovefield, Sequoiadb, Faircom DB , ModeShape, Brytlyt, Mimer SQL, IBM Db2 Event Store, Starcounter, OpenQM, atoti, 4store, Axibase, Tibco ComputeDB, Northgate Reality, SearchBlox, Tajo, Alibaba Cloud Table Store, Project Voldemort, AnzoGraph DB, PipelineDB, Fluree, Kyligence Enterprise , Alibaba Cloud TSDB, Riak TS, FlockDB, TDengine , EsgynDB, LeanXcale , KeyDB, GeoSpock, Actian FastObjects, Transbase, Memgraph , EJDB, Comdb2, ElevateDB, Quasardb , M3DB, Faircom EDGE , HyperGraphDB, Valentina Server, Milvus, Cloudflare Workers KV, XtremeData, Weaviate, TinkerGraph, HugeGraph, TerminusDB, TransLattice, DuckDB, ITTIA, Strabon, Apache IoTDB, Blueflood, STSdb, NEventStore, Warp 10, CubicWeb, Actian PSQL, H2GIS, VelocityDB, Mulgara, Sparksee, Badger, Machbase , Linter, SenseiDB, Heroic, ToroDB, SwayDB, InfinityDB, Dydra, BrightstarDB, Crux, BigObject, TerarkDB, Bangdb, GraphBase, SiriDB, Elliptics, WhiteDB, Kyoto Tycoon, RaptorDB, Hawkular Metrics, Upscaledb, Exorbyte, DensoDB, Yanza, WakandaDB, OrigoDB, LedisDB, Manticore Search, SmallSQL, AgensGraph, ActorDB, JethroData, SiteWhere, Siaqodb, FinchDB, RedStore, HGraphDB, ScaleOut StateServer, NosDB, SparkleDB, JaguarDB , CovenantSQL, BergDB, Cachelot.io, CortexDB, DaggerDB, Edge Intelligence, Eloquera, Helium, HyperLevelDB, Hyprcubd, iBoxDB, Indica, IRONdb, JasDB, JSqlDb, K-DB, Newts, NSDb, Resin Cache, Rizhiyi, Sadas Engine, searchxml, SpaceTime, SWC-DB, Tkrzw, TomP2P, Yaacomo'.split(/\s*,\s*/)
        
        const number = '1269.26, 1238.22, 973.35, 577.05, 496.54, 169.88, 165.46, 157.08, 129.81, 114.84, 113.66, 98.98, 90.60, 83.93, 75.15, 74.90, 68.82, 56.95, 55.57, 51.06, 50.28, 47.61, 46.54, 44.64, 42.03, 36.87, 30.22, 29.56, 27.82, 25.98, 25.35, 23.02, 22.86, 20.56, 20.16, 18.84, 18.75, 17.95, 15.71, 15.19, 13.82, 13.09, 12.18, 10.58, 9.81, 9.78, 9.53, 9.15, 9.08, 8.86, 7.99, 7.87, 7.79, 7.75, 7.22, 7.06, 6.81, 6.46, 6.35, 6.20, 6.14, 5.68, 5.53, 5.44, 5.22, 5.11, 5.06, 5.05, 4.94, 4.93, 4.87, 4.86, 4.80, 4.73, 4.53, 4.51, 4.41, 4.27, 4.27, 4.26, 4.23, 4.01, 4.01, 3.91, 3.86, 3.85, 3.72, 3.46, 3.41, 3.41, 3.38, 3.23, 3.20, 3.19, 3.00, 2.99, 2.92, 2.91, 2.80, 2.78, 2.70, 2.69, 2.59, 2.56, 2.54, 2.49, 2.49, 2.43, 2.40, 2.40, 2.22, 2.19, 2.18, 2.16, 2.12, 2.09, 2.08, 2.07, 1.98, 1.93, 1.90, 1.90, 1.90, 1.86, 1.83, 1.72, 1.72, 1.71, 1.69, 1.69, 1.68, 1.67, 1.67, 1.66, 1.64, 1.53, 1.53, 1.50, 1.48, 1.48, 1.47, 1.46, 1.37, 1.37, 1.36, 1.36, 1.34, 1.34, 1.33, 1.30, 1.30, 1.28, 1.28, 1.27, 1.24, 1.23, 1.22, 1.21, 1.20, 1.20, 1.18, 1.16, 1.15, 1.12, 1.12, 1.12, 1.11, 1.10, 1.10, 1.07, 1.05, 1.03, 1.02, 1.01, 0.98, 0.96, 0.96, 0.95, 0.94, 0.94, 0.93, 0.93, 0.92, 0.90, 0.90, 0.90, 0.88, 0.87, 0.87, 0.87, 0.86, 0.85, 0.84, 0.83, 0.83, 0.82, 0.82, 0.81, 0.80, 0.78, 0.75, 0.73, 0.73, 0.72, 0.72, 0.71, 0.71, 0.71, 0.70, 0.70, 0.68, 0.68, 0.68, 0.66, 0.64, 0.64, 0.63, 0.63, 0.63, 0.63, 0.63, 0.62, 0.61, 0.60, 0.59, 0.58, 0.57, 0.57, 0.56, 0.55, 0.55, 0.53, 0.53, 0.52, 0.52, 0.50, 0.50, 0.49, 0.49, 0.47, 0.47, 0.46, 0.46, 0.46, 0.45, 0.44, 0.43, 0.43, 0.43, 0.43, 0.43, 0.41, 0.39, 0.38, 0.38, 0.38, 0.38, 0.37, 0.37, 0.36, 0.35, 0.34, 0.34, 0.32, 0.31, 0.31, 0.30, 0.30, 0.30, 0.29, 0.28, 0.28, 0.28, 0.28, 0.27, 0.26, 0.26, 0.25, 0.24, 0.23, 0.22, 0.22, 0.21, 0.20, 0.20, 0.20, 0.20, 0.19, 0.19, 0.19, 0.19, 0.19, 0.18, 0.17, 0.17, 0.17, 0.16, 0.16, 0.16, 0.15, 0.15, 0.14, 0.14, 0.13, 0.13, 0.12, 0.12, 0.11, 0.11, 0.10, 0.10, 0.10, 0.09, 0.09, 0.09, 0.09, 0.09, 0.08, 0.08, 0.08, 0.07, 0.07, 0.06, 0.06, 0.06, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.04, 0.04, 0.04, 0.04, 0.04, 0.03, 0.02, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00'.split(/\s*,\s*/)

        const qq = [];
        sql.map(function(item,key){
            qq.push({
                資料庫名稱 : sql[key],
                分數: number[key]
            })
        })
        console.log(qq)
        // const qq = [];
        // sql.map((item,key) => {
        //     qq.push({
        //         資料庫名稱 : sql[key],
        //         分數: number[key]
        //     })
        // })
        // console.log(qq)

        
        // //80元以上列出來
        // const newName = [];                        //宣告newName 型態陣列
        // test.forEach(function(obj,key){            //給予參數1,2 分別為obj及key 參數1是物件內容,參數2是索引值,參數3是全部物件array( arr很少用到)
            //     if(obj.money >= 80){               //if如果obj內的money物件的內容大於等於80(字串或數值皆可) 
                //         newName.push(obj)          //將符合的obj物件內容push推給newName
                //     }
                // })
                
                //console.log(newName)                //console.log出來
                
        //filter function寫法
        // const newName = test.filter(function(obj,index){
        //     return obj.money >= 80;
        // })
        // console.log(newName)

        //filter 箭頭函式寫法 arrow(箭頭函式)
        //最短縮寫法    filter會判斷true或false值 true就回傳 這邊用箭頭函式就不用寫return 
        // const newName = test.filter((obj) => obj.money >= 80)   
        // console.log(newName)










        //把銅鑼燒改成超級銅鑼燒
        // //最後一個
        // let number = [];
        // test.forEach(function(item,key){
        //     if(item.thing === '銅鑼燒'){
        //         number = key;

        //     }
        // })
        // test[number].thing = '超級銅鑼燒';
        // console.log(test)

        // findIndex function寫法  列出一個
        // const number = test.findIndex(function(item){
        //     return item.thing === '銅鑼燒' 
        // })
        // test[number].thing = '超級銅鑼燒'; 
        // console.log(test[number])

        // findIndex 箭頭函式寫法 僅限第一個
        // const number = test.findIndex((item) => item.thing === '銅鑼燒')
        // test[number].thing = '超級銅鑼燒'
        // console.log(test )


        //多個寫法需用到迴圈  以下這個限於創造新陣列
        // const number = [];
        // test.forEach(function(item,key){
        //     if(item.thing === '銅鑼燒'){
        //         number.push({
        //             ...item,
        //             thing : '超級銅鑼燒'
        //         })
        //     }
        // })
        // console.log(number)


        // 需先用if判斷 將符合的key數值push給const number 裡面 再用let i of number將number值給i 用迴圈將對應的值的物件內容更改 此方法不建議使用 直接使用下面方法即可
        // const number = [];
        // for(let i of number){
        //     test[i].thing = '超級銅鑼燒';
        // }
        // console.log('for寫法 : ',test)
        
        // //多個寫法-放入forEach 符合物品時直接修改陣列裡的對應內容
        // test.forEach(function(item){
        //     if(item.thing === '銅鑼燒'){
        //         item.thing = '超級銅鑼燒'
        //     }
        // })
        // console.log('forEach寫法 : ',test);

        // const number = [];
        // test.forEach((item) => {  
        //     if(item.thing === '銅鑼燒'){
        //         item.thing = '超級銅鑼燒'
        //     }
        // })
        // console.log(test);

        // 箭頭函式+終極寫法 778表示不要白目
        // test.forEach((time) => time.thing === '銅鑼燒' && (time.thing = '超級銅鑼燒'))
        // console.log(test)
            










        //將姓名跟金額印出來 
        // let nameMoney = '';
        // test.forEach(function(item,key){     //下一行註解 nameMoney變數 等於 原先 + <li> ${item內的name} ,(跟) ${item內的money} </li>  樣板字面值使用方式為 `內容` 內容中使用到變數要${放裡面}
        //     nameMoney = nameMoney + `<li>       
        //         姓名 : ${item.name} <P> 價格 : ${item.money};
        //     </li>`;
        // })
        // console.log(nameMoney)

        //map會進行return 陣列有多長map回傳的結果就會多長
        // const nameMoney = test.map(function(item){            //使用map
        //     return `<li>
        //             姓名 : ${item.mame}<p> 價格 : ${item.money};
        //         </li>`;
        // }).join('')  //如果沒加''的話會有,   沒用join的話是陣列  join為轉為字串作用
        // console.log(nameMoney)

        // 箭頭函式 arrow寫法
        // const nameMoney = test.map((item) =>
        //     `<li>
        //     姓名 : ${item.name}<p> 價格 : ${item.money};
        // </li>`).join('')  
        // console.log(nameMoney)








        // //全部人的錢
        // let allMoney = 0;
        // test.forEach(function(item,key){
        //     allMoney += item.money;
        // })
        // console.log(allMoney)
        
        
        // reduce寫法           acc = accumulator , cur = currentValue
        // let allMoney = test.reduce(function(acc, cur){
        //     return acc + cur.money      //每次回傳值是acc本身+當前物件的money
        // },0);                           //這邊的0是acc的初始值
        // console.log(allMoney)

        // let allMoney = test.reduce((acc, cur) => acc + cur.money ,0);       //arrow箭頭函式不需要寫return 本身已自帶 範例程式碼參考上方 
        // console.log(allMoney)

        

        // //比較誰吃的貴  sort的判斷方式為數值傳遞的優先順序 透過return將傳遞的優先順序做排列
        // const newName = test.sort((a,b) => {
        //     return a.money - b.money;    //由小到大
        //     return b.money - a.money;    //由大到小
        // })
        // console.log(newName)



        // $(function(){
        //     $('#menu').html(nameMoney)       //實際修改
        // })









        // //以下是載入頁面後再執行js
        // window.addEventListener('load', (event) => {

        //     document.getElementById('menu').innerHTML = nameMoney;
        // })

        // window.addEventListener('load',function() {

        //     document.getElementById('menu').innerHTML = nameMoney;

        // })



    </script>

    

</head>
<body>
    <div id="menu">123</div>
    <script>
    </script>
</body>
</html>