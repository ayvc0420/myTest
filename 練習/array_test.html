<!DOCTYPE html>
<html lang="tw">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>array_test</title>
    <script src="js/jquery-3.6.0.min.js"></script>

    <script>
        //https://www.youtube.com/watch?v=_vFuDQ_6Xt8
        let test = [
            {
                name : '阿明',  
                thing : '草莓',
                money : 80
            },{
                name: '小可',
                thing : '銅鑼燒',
                money : 45
            },{
                name : '大壯',
                thing : '西瓜',
                money : 250
            },{
                name: '小P',
                thing : '西瓜',
                money : 120
            },
        ]



        
        // 查看obj跟key內容
        // test.forEach((obj,index) => {                    //兩個參數命名為obj跟key 可改
        //     console.log(obj,index)                       //obj對應上面的參數 是物件內容 key是索引值
        // })

        //轉換成陣列
        // const array = test.map(item => `${item.name},${item.thing},${item.money}` )
        // console.log(array)
        


        //將每個物件都新增一個新價格 命名為newMoney 價格設定money的8折
        //方法一 用push forEach迴圈重複多次將每個物件都推一個新內容進去
        // const newObj = [];                    //宣告陣列型態
        // test.forEach(function(obj,key){       //test物件執行forEach迴圈 
        //     newObj.push({                     //push語法 .push({內容})
        //         ...obj,                       //展開obj物件
        //         newMoney : obj.money*0.8      //新建物件newMoney 對應: obj.money * 0.8 取obj裡的money數值*0.8
        //     })
        // })
        // console.log(newObj)

        // const newObj = [];              
        // test.forEach(function(obj,key){    //forEach根據陣列內有幾個物件而決定做幾次for迴圈
        //     newObj [key]={                 //根據索引值將每個物件內容都執行    26:35影片位置 ES6寫法
        //         ...obj,                    //展開 在這裡為展開obj內容
        //         newMoney: obj.money*0.8    //建立新物件newMoney 對應 obj(原先物件).money(裡面的money) * 0.8
        //     } 
        // })
        // console.log(newObj)

        //方法二 .map 比上面更好
        // const change = test.map(function(obj,key){
        //     return{                                  //回傳
        //         ...obj,                              //展開
        //         newMoney : obj.money * 0.8           //建立新物件
        //     }
        // })
        // console.log(change)

        //方法三 .map的箭頭函式
        // const change = test.map((obj,key,arr) => ({
        //                                              //箭頭函式已經自帶return 因此不用寫
        //         ...obj,                              //展開
        //         newMoney : obj.money * 0.8           //建立新物件
        //     }));
            
        // console.log(change)
        
        //上面簡寫
        // const change = test.map(item => ({...item,newMoney : item.money * 0.8}))
        // console.log(change)








        // 將物件內的個別對應單獨提取至其他陣列 但該用處毫無意義 
        // const test1 = test.map(obj => `${obj.name}`)
        // const test2 = test.map(obj => `${obj.thing}`)
        // const test3 = test.map(obj => `${obj.money}`)
        // console.log(test1,test2,test3)
        // const test4 = test3.map(item => parseInt(item , 10))  // parseInt = 字串轉換為整數 用於+-/*
        // const test5 = test4.reduce((acc,money) =>  acc + money ,0 );  //
        // console.log(test5)
        // const qq = [];
        // const qq1 = [];
        // const qq2 = [];
        // const qq3 = [];
        
        // test.forEach(item => {
        //     qq1.push(item.name)
        //     qq2.push(item.thing)
        //     qq3.push(item.money)
        // })
        // // qq.push('姓名:',qq1,
        // //         '物品:',qq2,
        // //         '金額:',qq3)
        
        // qq.push( `<a>姓名:${qq1}, <br> 物品:${qq2}, <br> 金額:${qq3}</a>` )
        // console.log(qq)


        // $(function(){
        //     $('#menu').html(qq);
        // })
        // // $(function(){
        // //     $('#menu').html(`<a>姓名:${qq1}, <br> 物品:${qq2}, <br> 金額:${qq3}</a>`);
        // // })
        // console.log(qq)







        // //100元以上列出來
        // const newName = [];                        //宣告newName 型態陣列
        // test.forEach(function(obj,key){            //給予參數1,2 分別為obj及key 參數1是物件內容,參數2是索引值,參數3是全部物件array( arr很少用到)
            //     if(obj.money >= 100){               //if如果obj內的money物件的內容大於等於100(字串或數值皆可) 
                //         newName.push(obj)          //將符合的obj物件內容push推給newName
                //     }
                // })
                
                //console.log(newName)                //console.log出來
                
        //filter function寫法
        // const newName = test.filter(function(obj,index){
        //     return obj.money >= 100;
        // })
        // console.log(newName)

        //filter 箭頭函式寫法 arrow(箭頭函式)
        //最短縮寫法    filter會判斷true或false值 true就回傳 這邊用箭頭函式就不用寫return 
        // const newName = test.filter((obj) => obj.money >= 100)   
        // console.log(newName)





        //將物件內符合西瓜的thing新增一個物件 給予名稱為升級後產品 對應內容為黃金西瓜
        // const dessert = [];
        // test.forEach((item,key) => {
        //     if(item.thing === '西瓜'){
        //         dessert.push({
        //             ...item,
        //             升級後產品 : '黃金西瓜'
        //         })
        //     }
        // })
        // console.log(dessert)


        //把西瓜改成黃金西瓜
        // //最後一個
        // let number = [];
        // test.forEach(function(item,key){
        //     if(item.thing === '西瓜'){
        //         number = key;

        //     }
        // })
        // test[number].thing = '黃金西瓜';
        // console.log(test)

        // findIndex function寫法  列出一個
        // const number = test.findIndex(function(item){
        //     return item.thing === '西瓜' 
        // })
        // test[number].thing = '黃金西瓜'; 
        // console.log(test[number])

        // findIndex 箭頭函式寫法 僅限第一個
        // const number = test.findIndex((item) => item.thing === '西瓜')
        // test[number].thing = '黃金西瓜'
        // console.log(test )


        //多個寫法需用到迴圈  以下這個限於創造新陣列
        // const number = [];
        // test.forEach(function(item,key){
        //     if(item.thing === '西瓜'){
        //         number.push({
        //             ...item,
        //             thing : '黃金西瓜'
        //         })
        //     }
        // })
        // console.log(number)


        // 需先用if判斷 將符合的key數值push給const number 裡面 再用let i of number將number值給i 用迴圈將對應的值的物件內容更改 此方法不建議使用 直接使用下面方法即可
        // const number = [];
        // for(let i of number){
        //     test[i].thing = '黃金西瓜';
        // }
        // console.log('for寫法 : ',test)
        
        // //多個寫法-放入forEach 符合物品時直接修改陣列裡的對應內容
        // test.forEach(function(item){
        //     if(item.thing === '西瓜'){
        //         item.thing = '黃金西瓜'
        //     }
        // })
        // console.log('forEach寫法 : ',test);

        // const number = [];
        // test.forEach((item) => {  
        //     if(item.thing === '西瓜'){
        //         item.thing = '黃金西瓜'
        //     }
        // })
        // console.log(test);

        // 箭頭函式+終極寫法 
        // test.forEach((time) => time.thing === '西瓜' && (time.thing = '黃金西瓜'))
        // console.log(test)
            










        //將姓名跟金額印出來 
        // let nameMoney = '';
        // test.forEach(function(item,key){     //下一行註解 nameMoney變數 等於 原先 + <li> ${item內的name} ,(跟) ${item內的money} </li>  樣板字面值使用方式為 `內容` 內容中使用到變數要${放裡面}
        //     nameMoney = nameMoney + `<li>       
        //         姓名 : ${item.name} <P> 價格 : ${item.money};
        //     </li>`;
        // })
        // console.log(nameMoney)

        //map會進行return 陣列有多長map回傳的結果就會多長
        // const nameMoney = test.map(function(item){            //使用map
        //     return `<li>
        //             姓名 : ${item.mame}<p> 價格 : ${item.money};
        //         </li>`;
        // }).join('')  //如果沒加''的話會有,   沒用join的話是陣列  join為轉為字串作用
        // console.log(nameMoney)

        // 箭頭函式 arrow寫法
        // const nameMoney = test.map((item) =>
        //     `<li>
        //     姓名 : ${item.name}<p> 價格 : ${item.money};
        // </li>`).join('')  
        // console.log(nameMoney)








        // //全部人的錢
        // let allMoney = 0;
        // test.forEach(function(item,key){
        //     allMoney += item.money;
        // })
        // console.log(allMoney)
        
        
        // reduce寫法           acc = accumulator , cur = currentValue
        // let allMoney = test.reduce(function(acc, cur){
        //     return acc + cur.money      //每次回傳值是acc本身+當前物件的money
        // },0);                           //這邊的0是acc的初始值
        // console.log(allMoney)

        // let allMoney = test.reduce((acc, cur) => acc + cur.money ,0);       //arrow箭頭函式不需要寫return 本身已自帶 範例程式碼參考上方 
        // console.log(allMoney)

        

        // //比較誰吃的貴  sort的判斷方式為數值傳遞的優先順序 透過return將傳遞的優先順序做排列
        // const newName = test.sort((a,b) => {
        //     return a.money - b.money;    //由小到大
        //     return b.money - a.money;    //由大到小
        // })
        // console.log(newName)



        // $(function(){
        //     $('#menu').html(nameMoney)       //實際修改
        // })









        // //以下是載入頁面後再執行js
        // window.addEventListener('load', (event) => {

        //     document.getElementById('menu').innerHTML = nameMoney;
        // })

        // window.addEventListener('load',function() {

        //     document.getElementById('menu').innerHTML = nameMoney;

        // })



    </script>

    

</head>
<body>
    <div id="menu">123</div>
    <script>
    </script>
</body>
</html>